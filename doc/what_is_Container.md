## 가상머신(VM) vs 컨테이너

### 가상 머신
물리적 하드웨어 하나의 자원을 나눠 독립된 실행환경을 제공하는 가상화 방식
- **Hyperviser** (vmware 등) 위에 **guest os**를 올려 서비스를 동작함

- 각 실행환경에 `guest os`가 포함되므로 속도가 느리고 많은 용량 차지, 

- 실제 하드웨어 환경에 따라 실행 불가 가능성 존재
- 그럼에도 `host os`와 독립된 환경으로서 보안 수준은 높음

### 컨테이너
하나의 완전한 실행환경이 아닌 각 **프로세스를 격리**하는 방식의 가상화 방식

**docker** 위에 컨테이너를 올려서 각 모듈을 동작하며 전체적인 서비스 구성 가능

- 하나의 서비스를 구성하는 모듈을 격리하고 이를 통해 서비스를 운용하는 방식

- `host os`를 공유하는 방식이므로 가상머신에 비해 빠르고 적은 용량 차지함

- 각 모듈별로 적절한 환경(언어 등) 을 구성할 수 있어 더 효율적인 서비스 운용 가능

- 다만 각 모듈 별로 os가 독립되지 않아 보안성은 가상머신에 비해 낮은 편

---

## 컨테이너 vs 이미지

- **이미지(Image)**: 실행 가능한 컨테이너의 **템플릿**. 읽기 전용이며, 애플리케이션과 필요한 실행환경(라이브러리 등)을 포함.
- **컨테이너(Container)**: 이미지를 기반으로 실행된 **실행 인스턴스**. 쓰기 가능한 계층을 포함하고, 상태와 로그 등을 포함함.

---

## 컨테이너 런타임(Container Runtime)이란?

컨테이너를 생성, 실행, 정지, 삭제하는 **소프트웨어 컴포넌트**.

host 커널과 통신하며 격리 환경을 구성하는 등 로우레벨 기능 담당

 Docker가 사용하는 컨테이너 런타임은 `containerd` 및 그 하위의 `runc`이다.

컨테이너 런타임은 Linux의 namespace, cgroups 기능을 활용해 프로세스를 격리하고 실행한다.


---

## 주요 컨테이너 런타임

1. **containerd**
   - Docker의 핵심 런타임 환경
   - 고성능, 안정적 컨테이너 관리 가능
   - 보안 성능은 높은 편

2. **CRI-O**
   - Kubernetes용으로 최적화된 경량 런타임.
   - Open Container Initiative(OCI) 이미지 호환
    - OCI란? 컨테이너 포맷 및 런타임 표준
    - `docker`의 경우 `runc`를 통해 OCI 호환
   - 경량화 및 빠른 동작 속도에 강점

3. **gVisor**
   - Google이 개발한 샌드박스 기반 런타임.
   - 컨테이너와 host os 사이에 추가 격리를 진행하는 방식
   - 컨테이너의 약점인 host os의 보안 문제를 일부 해결

---

## Docker 이미지의 레이어 구조

Docker 이미지는 **읽기 전용 레이어들의 집합**으로 구성됨.

이미지의 일부 변경사항으로 인해 이미지 전체를 다시 받는 일을 방지하기 위함

- 각 Dockerfile 명령어(예: `RUN`, `COPY`, `ADD`)는 새로운 레이어를 생성함.
- 레이어는 **캐시 가능**하며, 중복 없이 공유 가능.
- 컨테이너가 실행되면 위에 쓰기 가능한 **컨테이너 레이어**가 추가되어 변경사항을 기록함. 
- 일종의 커밋 트리와 유사한 방식

예시:
```Dockerfile
FROM ubuntu       # 베이스 레이어
RUN apt install   # 새 레이어 생성
COPY . /app       # 또 다른 레이어 생성
